/**
 * E2E ISA Websearch Pipeline Tests
 *
 * Validates the full 6-stage ISA Deep Research pipeline with the new
 * Stage 1 (websearch_calibration) using the real config.json.
 *
 * Tests:
 * - Config/AGENT.md cross-validation (stage IDs, names, schemas)
 * - Websearch accepted path: Stage 0 pause -> Stage 1 execute -> Stage 1 pause -> Stages 2-5
 * - Websearch declined path: Stage 0 pause -> Stage 1 skip (via modify) -> Stage 1 pause -> Stages 2-5
 * - Quick mode path: Stage 1 auto-skip (enableWebSearch: false)
 * - Repair unit consistency with renumbered stages [3, 4]
 * - Double-pause scenario (pause at stage 0 AND stage 1)
 * - Stage output schema validation for all 6 stages
 *
 * Run: npx tsx --test apps/electron/src/__tests__/e2e-isa-websearch-pipeline.test.ts
 */

import { describe, it, afterEach } from 'node:test';
import assert from 'node:assert/strict';
import { join } from 'node:path';
import { readFileSync, existsSync, writeFileSync, mkdirSync, readdirSync } from 'node:fs';
import {
  E2ESessionHarness,
} from '../../../../packages/agent-pipeline-core/src/handlers/__tests__/e2e-utils.ts';
import {
  validateAgentEventsLog,
  validateRunState,
  assertEventSequence,
  assertPauseOutcome,
  assertNoDuplicateCompletes,
} from '../../../../packages/agent-pipeline-core/src/handlers/__tests__/e2e-session-validators.ts';

// ============================================================
// Load Real ISA Config
// ============================================================

const ISA_AGENT_CONFIG_PATH = join(
  process.cwd(),
  'agents',
  'isa-deep-research',
  'config.json',
);

const ISA_AGENT_MD_PATH = join(
  process.cwd(),
  'agents',
  'isa-deep-research',
  'AGENT.md',
);

function loadRealISAConfig(): Record<string, unknown> {
  assert.ok(
    existsSync(ISA_AGENT_CONFIG_PATH),
    `Real ISA config must exist at ${ISA_AGENT_CONFIG_PATH}`,
  );
  return JSON.parse(readFileSync(ISA_AGENT_CONFIG_PATH, 'utf-8')) as Record<string, unknown>;
}

function loadRealAgentMd(): string {
  assert.ok(
    existsSync(ISA_AGENT_MD_PATH),
    `AGENT.md must exist at ${ISA_AGENT_MD_PATH}`,
  );
  return readFileSync(ISA_AGENT_MD_PATH, 'utf-8');
}

/**
 * Load AGENT.md + all prompts/stage-*.md content for body assertions.
 * Stage instructions now live in individual prompt files.
 */
function loadAllAgentContent(): string {
  let content = loadRealAgentMd();
  const promptsDir = join(process.cwd(), 'agents', 'isa-deep-research', 'prompts');
  if (existsSync(promptsDir)) {
    const files = readdirSync(promptsDir).filter(f => f.endsWith('.md')).sort();
    for (const f of files) {
      content += '\n' + readFileSync(join(promptsDir, f), 'utf-8');
    }
  }
  return content;
}

/**
 * Write the Stage 5 output file to the harness's plans folder.
 * Required because the stage gate now verifies the file exists on disk.
 */
function writeStage5OutputFile(harness: E2ESessionHarness): void {
  const plansFolder = harness.ctx.plansFolderPath;
  mkdirSync(plansFolder, { recursive: true });
  writeFileSync(
    join(plansFolder, 'isa-research-output.md'),
    '# ISA Research: Test Output\n\n> Generated by ISA Deep Research Agent | Test\n\nThis is the full research output for testing.',
    'utf-8',
  );
}

// ============================================================
// Sample stage outputs matching config schemas
// ============================================================

const STAGE_0_OUTPUT = {
  query_plan: {
    original_query: 'What does ISA 315 require for risk assessment?',
    clarity_score: 0.85,
    sub_queries: [
      { query: 'ISA 315 risk assessment requirements', role: 'primary', target_standards: ['315'] },
      { query: 'ISA 315 inherent risk factors', role: 'supporting', target_standards: ['315'] },
      { query: 'ISA 330 responses to assessed risks', role: 'context', target_standards: ['330'] },
    ],
    depth_mode: 'standard',
    primary_standards: ['ISA 315'],
    assumptions: ['Focus on revised ISA 315 (2019)'],
    alternative_interpretations: [],
    recommended_action: 'proceed',
    scope: 'ISA 315 risk assessment framework and related requirements',
    authority_sources: {
      search_queries: ['ISA 315 risk assessment 2019', 'IAASB ISA 315 revised', 'ISA 315 implementation guide'],
      domain_hints: ['ifac.org', 'iaasb.org', 'pcaobus.org'],
      source_types: ['standard-setting', 'implementation-guide'],
    },
  },
};

const STAGE_1_OUTPUT_EXECUTED = {
  websearch_calibration: {
    skipped: false,
    web_queries_executed: 3,
    web_sources: [
      { url: 'https://ifac.org/isa-315', title: 'ISA 315 Implementation Guide', relevance_note: 'Primary guidance' },
    ],
    intent_changes: {
      sub_queries_added: [{ query: 'ISA 315.A2 forward-looking', role: 'primary', reason: 'IFAC guidance' }],
      sub_queries_modified: [],
      sub_queries_removed: [],
      scope_changed: false,
      standards_added: [],
    },
    query_plan_refined: true,
  },
};

const STAGE_1_OUTPUT_SKIPPED_USER = {
  websearch_calibration: {
    skipped: true,
    skip_reason: 'user_declined',
    web_queries_executed: 0,
    web_sources: [],
    intent_changes: {
      sub_queries_added: [],
      sub_queries_modified: [],
      sub_queries_removed: [],
      scope_changed: false,
      standards_added: [],
    },
    query_plan_refined: false,
  },
};

const STAGE_1_OUTPUT_SKIPPED_QUICK = {
  websearch_calibration: {
    skipped: true,
    skip_reason: 'quick_mode',
    web_queries_executed: 0,
    web_sources: [],
    intent_changes: {
      sub_queries_added: [],
      sub_queries_modified: [],
      sub_queries_removed: [],
      scope_changed: false,
      standards_added: [],
    },
    query_plan_refined: false,
  },
};

const STAGE_2_OUTPUT = {
  retrieval_summary: {
    total_paragraphs_found: 45,
    unique_after_dedup: 32,
    standards_covered: ['ISA 315', 'ISA 330'],
    role_counts: { primary: 20, supporting: 8, context: 4 },
    skipped_sub_queries: [],
  },
};

const STAGE_3_OUTPUT = {
  synthesis: 'ISA 315 requires the auditor to identify and assess risks...',
  citations_used: [
    { paragraph_id: 'ip_001', paragraph_ref: '315.12(a)', claim: 'risk assessment requirement' },
  ],
};

const STAGE_4_OUTPUT = {
  verification_scores: {
    entity_grounding: { score: 0.92, passed: true },
    citation_accuracy: { score: 0.88, passed: true },
    relation_preservation: { score: 0.75, passed: true },
    contradictions: { count: 0, passed: true },
  },
  all_passed: true,
  source_texts: {
    'ISA 315.12(a)': 'The auditor shall identify and assess the risks of material misstatement.',
  },
  missing_source_texts: [],
};

const STAGE_5_OUTPUT = {
  answer_delivered: true,
  total_citations: 12,
  output_file_path: './isa-research-output.md',
  source_texts_used: 15,
  renderer_tool_called: true,
};

// ============================================================
// Tests: Config / AGENT.md Cross-Validation
// ============================================================

describe('E2E ISA Websearch Pipeline — Config Cross-Validation', () => {
  it('config.json has exactly 6 stages with IDs 0-5', () => {
    const config = loadRealISAConfig() as {
      controlFlow: { stages: Array<{ id: number; name: string; description: string }> };
    };
    const stages = config.controlFlow.stages;

    assert.equal(stages.length, 6, `Expected 6 stages, got ${stages.length}`);
    for (let i = 0; i < 6; i++) {
      assert.equal(stages[i]!.id, i, `Stage ${i} should have id=${i}, got ${stages[i]!.id}`);
      assert.ok(stages[i]!.name.length > 0, `Stage ${i} must have a name`);
      assert.ok(stages[i]!.description.length > 0, `Stage ${i} must have a description`);
    }
  });

  it('stage names match between config.json and AGENT.md', () => {
    const config = loadRealISAConfig() as {
      controlFlow: { stages: Array<{ id: number; name: string }> };
    };
    const allContent = loadAllAgentContent();

    // Map config stage names to expected header patterns (in AGENT.md or prompts/)
    const expectedMdHeaders: Record<string, string> = {
      'analyze_query': 'Stage 0: Analyze Query',
      'websearch_calibration': 'Stage 1: Websearch Calibration',
      'retrieve': 'Stage 2: Retrieve',
      'synthesize': 'Stage 3: Synthesize',
      'verify': 'Stage 4: Verify',
      'output': 'Stage 5: Output',
    };

    for (const stage of config.controlFlow.stages) {
      const expectedHeader = expectedMdHeaders[stage.name];
      assert.ok(
        expectedHeader,
        `Config stage name "${stage.name}" should have a known header mapping`,
      );
      assert.ok(
        allContent.includes(expectedHeader!),
        `Agent definition should contain header "${expectedHeader}" for config stage "${stage.name}" (id=${stage.id})`,
      );
    }
  });

  it('pauseAfterStages includes both stage 0 and stage 1', () => {
    const config = loadRealISAConfig() as {
      controlFlow: { pauseAfterStages: number[] };
    };
    assert.deepEqual(
      config.controlFlow.pauseAfterStages.sort(),
      [0, 1],
      `pauseAfterStages should be [0, 1], got ${JSON.stringify(config.controlFlow.pauseAfterStages)}`,
    );
  });

  it('repairUnits references stages [3, 4] (synthesize, verify)', () => {
    const config = loadRealISAConfig() as {
      controlFlow: {
        repairUnits: Array<{ stages: [number, number]; maxIterations: number }>;
        stages: Array<{ id: number; name: string }>;
      };
    };

    assert.equal(config.controlFlow.repairUnits.length, 1, 'Should have exactly 1 repair unit');
    const ru = config.controlFlow.repairUnits[0]!;
    assert.deepEqual(ru.stages, [3, 4], `Repair unit should be [3, 4], got [${ru.stages}]`);

    // Verify stages 3 and 4 are synthesize and verify
    const stage3 = config.controlFlow.stages.find(s => s.id === 3);
    const stage4 = config.controlFlow.stages.find(s => s.id === 4);
    assert.equal(stage3?.name, 'synthesize', 'Stage 3 should be synthesize');
    assert.equal(stage4?.name, 'verify', 'Stage 4 should be verify');
  });

  it('repair loop stages are defined in config repairUnits', () => {
    const config = loadRealISAConfig() as {
      controlFlow: {
        repairUnits: Array<{ stages: number[] }>;
        stages: Array<{ id: number; name: string }>;
      };
    };

    // Repair loop references are validated through config.json structure
    // (stage instructions live in prompts/stage-*.md, repair logic in config)
    const ru = config.controlFlow.repairUnits[0]!;
    assert.deepEqual(ru.stages, [3, 4], 'Repair unit should cover stages 3 and 4');

    // Verify the repair prompt exists
    const allContent = loadAllAgentContent();
    assert.ok(
      allContent.includes('Repair') || allContent.includes('repair'),
      'Agent prompts should reference repair behavior',
    );
  });

  it('stageOutputSchemas has keys for all 6 stages', () => {
    const config = loadRealISAConfig() as {
      controlFlow: { stageOutputSchemas: Record<string, unknown> };
    };
    const schemas = config.controlFlow.stageOutputSchemas;

    for (let i = 0; i <= 5; i++) {
      assert.ok(
        String(i) in schemas,
        `stageOutputSchemas should have key "${i}", found: ${Object.keys(schemas).join(', ')}`,
      );
    }
  });

  it('stage 1 schema requires websearch_calibration with correct nested fields', () => {
    const config = loadRealISAConfig() as {
      controlFlow: {
        stageOutputSchemas: Record<string, {
          required: string[];
          properties: Record<string, { type: string; required?: string[]; properties?: Record<string, unknown> }>;
        }>;
      };
    };
    const schema = config.controlFlow.stageOutputSchemas['1']!;

    assert.ok(schema.required.includes('websearch_calibration'), 'Stage 1 schema should require websearch_calibration');

    const wcProps = schema.properties.websearch_calibration;
    assert.equal(wcProps.type, 'object');
    assert.ok(wcProps.required!.includes('skipped'), 'websearch_calibration should require skipped');
    assert.ok(wcProps.required!.includes('query_plan_refined'), 'websearch_calibration should require query_plan_refined');
  });

  it('stages 0 and 1 have pauseInstructions, stages 2-5 do not', () => {
    const config = loadRealISAConfig() as {
      controlFlow: { stages: Array<{ id: number; pauseInstructions?: string }> };
    };

    for (const stage of config.controlFlow.stages) {
      if (stage.id <= 1) {
        assert.ok(
          stage.pauseInstructions && stage.pauseInstructions.length > 0,
          `Stage ${stage.id} should have pauseInstructions`,
        );
      } else {
        assert.equal(
          stage.pauseInstructions,
          undefined,
          `Stage ${stage.id} should NOT have pauseInstructions`,
        );
      }
    }
  });

  it('quick mode disables web search', () => {
    const config = loadRealISAConfig() as {
      depthModes: { quick: { enableWebSearch: boolean } };
    };
    assert.equal(
      config.depthModes.quick.enableWebSearch,
      false,
      'Quick mode should have enableWebSearch: false',
    );
  });

  it('debug config has skipWebSearch flag', () => {
    const config = loadRealISAConfig() as {
      debug: { skipWebSearch: boolean };
    };
    assert.equal(
      typeof config.debug.skipWebSearch,
      'boolean',
      'debug.skipWebSearch should be a boolean',
    );
  });
});

// ============================================================
// Tests: Full Pipeline Paths Using Stage Gate Handler
// ============================================================

describe('E2E ISA Websearch Pipeline — Websearch Accepted Path', () => {
  let harness: E2ESessionHarness;

  afterEach(() => {
    harness?.cleanup();
  });

  it('full pipeline: Stage 0 pause -> resume -> Stage 1 execute -> pause -> resume -> Stages 2-5', async () => {
    const config = loadRealISAConfig();
    harness = E2ESessionHarness.create({ agentConfig: config });

    // Stage 0: start -> complete -> PAUSE
    await harness.gate('reset', undefined, { force: true });
    await harness.gate('start', 0);
    const s0Complete = await harness.gate('complete', 0, STAGE_0_OUTPUT);

    assert.equal(s0Complete.pauseRequired, true, 'Stage 0 should trigger pause');
    assert.equal(s0Complete.allowed, false, 'allowed should be false when paused');

    // Verify run state is paused at stage 0
    const state0 = harness.readRunState();
    assert.equal(state0.pausedAtStage, 0, 'Run state should show pausedAtStage=0');

    // Resume with proceed (user accepted websearch)
    const resume0 = await harness.gate('resume', undefined, { decision: 'proceed' });
    assert.equal(resume0.allowed, true, 'resume-proceed should succeed');
    assert.equal(resume0.nextStage, 1, 'Next stage after stage 0 resume should be 1');

    // Stage 1: start -> complete (websearch executed) -> PAUSE
    const s1Start = await harness.gate('start', 1);
    assert.equal(s1Start.allowed, true, 'start(1) should succeed after resume');

    const s1Complete = await harness.gate('complete', 1, STAGE_1_OUTPUT_EXECUTED);
    assert.equal(s1Complete.pauseRequired, true, 'Stage 1 should trigger pause');
    assert.equal(s1Complete.allowed, false, 'allowed should be false when paused at stage 1');

    // Verify run state is paused at stage 1
    const state1 = harness.readRunState();
    assert.equal(state1.pausedAtStage, 1, 'Run state should show pausedAtStage=1');

    // Resume stage 1
    const resume1 = await harness.gate('resume', undefined, { decision: 'proceed' });
    assert.equal(resume1.allowed, true, 'resume after stage 1 should succeed');
    assert.equal(resume1.nextStage, 2, 'Next stage after stage 1 resume should be 2');

    // Stages 2-5: no pauses, run straight through
    await harness.gate('start', 2);
    const s2Complete = await harness.gate('complete', 2, STAGE_2_OUTPUT);
    assert.equal(s2Complete.pauseRequired, false, 'Stage 2 should NOT pause');

    await harness.gate('start', 3);
    const s3Complete = await harness.gate('complete', 3, STAGE_3_OUTPUT);
    assert.equal(s3Complete.pauseRequired, false, 'Stage 3 should NOT pause');

    await harness.gate('start', 4);
    const s4Complete = await harness.gate('complete', 4, STAGE_4_OUTPUT);
    assert.equal(s4Complete.pauseRequired, false, 'Stage 4 should NOT pause');

    writeStage5OutputFile(harness);
    await harness.gate('start', 5);
    const s5Complete = await harness.gate('complete', 5, STAGE_5_OUTPUT);
    assert.equal(s5Complete.pauseRequired, false, 'Stage 5 should NOT pause');

    // Verify all 6 stages completed
    const finalState = harness.readRunState();
    const completedStages = finalState.completedStages as number[];
    assert.equal(completedStages.length, 6, 'All 6 stages should be completed');
    for (let i = 0; i <= 5; i++) {
      assert.ok(completedStages.includes(i), `Stage ${i} should be in completedStages`);
    }

    // Verify event log has correct lifecycle
    const events = validateAgentEventsLog(harness.ctx, harness.agentSlug);
    assertEventSequence(events, [
      'agent_run_started',     // start(0)
      'stage_completed',       // complete(0)
      'stage_gate_pause',      // pause at 0
      'stage_gate_resumed',    // resume
      'stage_started',         // start(1)
      'stage_completed',       // complete(1)
      'stage_gate_pause',      // pause at 1
      'stage_gate_resumed',    // resume
      'stage_started',         // start(2)
      'stage_completed',       // complete(2)
      'stage_started',         // start(3)
      'stage_completed',       // complete(3)
      'stage_started',         // start(4)
      'stage_completed',       // complete(4)
      'stage_started',         // start(5)
      'stage_completed',       // complete(5)
      'agent_run_completed',   // all stages done
    ]);

    assertNoDuplicateCompletes(events);
  });

  it('Stage 0 pauseInstructions contain WEBSEARCH QUESTION section', async () => {
    const config = loadRealISAConfig();
    harness = E2ESessionHarness.create({ agentConfig: config });

    await harness.gate('reset', undefined, { force: true });
    await harness.gate('start', 0);
    const result = await harness.gate('complete', 0, STAGE_0_OUTPUT);

    const reason = result.reason as string;
    assert.ok(
      reason.includes('WEBSEARCH QUESTION') || reason.includes('web search'),
      `Stage 0 pause reason should mention websearch. Got first 300 chars: ${reason.substring(0, 300)}`,
    );
  });

  it('Stage 1 pauseInstructions contain CALIBRATED/CONFIRMED format', async () => {
    const config = loadRealISAConfig();
    harness = E2ESessionHarness.create({ agentConfig: config });

    await harness.gate('reset', undefined, { force: true });
    await harness.gate('start', 0);
    await harness.gate('complete', 0, STAGE_0_OUTPUT);
    await harness.gate('resume', undefined, { decision: 'proceed' });
    await harness.gate('start', 1);
    const result = await harness.gate('complete', 1, STAGE_1_OUTPUT_EXECUTED);

    const reason = result.reason as string;
    assert.ok(
      reason.includes('CALIBRATED') && reason.includes('CONFIRMED'),
      `Stage 1 pause reason should mention CALIBRATED and CONFIRMED. Got first 300 chars: ${reason.substring(0, 300)}`,
    );
  });
});

// ============================================================
// Tests: Websearch Declined Path
// ============================================================

describe('E2E ISA Websearch Pipeline — Websearch Declined Path', () => {
  let harness: E2ESessionHarness;

  afterEach(() => {
    harness?.cleanup();
  });

  it('resume-modify with skip_websearch passes modifications to stage 1 start', async () => {
    const config = loadRealISAConfig();
    harness = E2ESessionHarness.create({ agentConfig: config });

    // Stage 0 -> pause
    await harness.gate('reset', undefined, { force: true });
    await harness.gate('start', 0);
    await harness.gate('complete', 0, STAGE_0_OUTPUT);

    // Resume with modify (user declined websearch)
    const resume = await harness.gate('resume', undefined, {
      decision: 'modify',
      modifications: { skip_websearch: true },
    });
    assert.equal(resume.allowed, true);
    assert.deepEqual(resume.modifications, { skip_websearch: true });

    // Start stage 1 — modifications should be delivered
    const s1Start = await harness.gate('start', 1);
    assert.equal(s1Start.allowed, true);
    assert.deepEqual(
      s1Start.modifications,
      { skip_websearch: true },
      'Modifications should be passed to stage 1 start',
    );

    // Complete stage 1 with skipped output
    const s1Complete = await harness.gate('complete', 1, STAGE_1_OUTPUT_SKIPPED_USER);
    assert.equal(s1Complete.pauseRequired, true, 'Stage 1 still pauses even when skipped');

    // Resume and continue through remaining stages
    await harness.gate('resume', undefined, { decision: 'proceed' });
    for (let s = 2; s <= 5; s++) {
      if (s === 5) writeStage5OutputFile(harness);
      await harness.gate('start', s);
      const output = s === 2 ? STAGE_2_OUTPUT : s === 3 ? STAGE_3_OUTPUT : s === 4 ? STAGE_4_OUTPUT : STAGE_5_OUTPUT;
      await harness.gate('complete', s, output);
    }

    // Verify completion
    const finalState = harness.readRunState();
    assert.equal((finalState.completedStages as number[]).length, 6);
  });

  it('modifications are consumed after stage 1 start (not re-delivered to stage 2)', async () => {
    const config = loadRealISAConfig();
    harness = E2ESessionHarness.create({ agentConfig: config });

    await harness.gate('reset', undefined, { force: true });
    await harness.gate('start', 0);
    await harness.gate('complete', 0, STAGE_0_OUTPUT);

    // Resume with modify
    await harness.gate('resume', undefined, {
      decision: 'modify',
      modifications: { skip_websearch: true },
    });

    // Start stage 1 consumes modifications
    const s1Start = await harness.gate('start', 1);
    assert.ok(s1Start.modifications, 'Stage 1 start should receive modifications');

    // Complete stage 1 and resume
    await harness.gate('complete', 1, STAGE_1_OUTPUT_SKIPPED_USER);
    await harness.gate('resume', undefined, { decision: 'proceed' });

    // Start stage 2 should NOT have modifications
    const s2Start = await harness.gate('start', 2);
    assert.equal(
      s2Start.modifications,
      undefined,
      'Stage 2 start should NOT receive modifications (consumed by stage 1)',
    );
  });
});

// ============================================================
// Tests: Quick Mode Path
// ============================================================

describe('E2E ISA Websearch Pipeline — Quick Mode Path', () => {
  let harness: E2ESessionHarness;

  afterEach(() => {
    harness?.cleanup();
  });

  it('quick mode: stage 1 completes as skipped, pipeline runs all 6 stages', async () => {
    const config = loadRealISAConfig();
    harness = E2ESessionHarness.create({ agentConfig: config });

    // Stage 0 with quick depth
    const quickPlan = {
      query_plan: {
        original_query: 'What is ISA 200?',
        clarity_score: 0.95,
        sub_queries: [{ query: 'ISA 200 definition', role: 'primary', target_standards: ['200'] }],
        depth_mode: 'quick',
        primary_standards: ['ISA 200'],
        recommended_action: 'proceed',
      },
    };

    await harness.gate('reset', undefined, { force: true });
    await harness.gate('start', 0);
    await harness.gate('complete', 0, quickPlan);

    // Resume (even in quick mode, stage 0 pauses for user confirmation)
    await harness.gate('resume', undefined, { decision: 'proceed' });

    // Stage 1: start -> complete with skip (quick mode)
    await harness.gate('start', 1);
    const s1Complete = await harness.gate('complete', 1, STAGE_1_OUTPUT_SKIPPED_QUICK);
    assert.equal(s1Complete.pauseRequired, true, 'Stage 1 pauses even when skipped in quick mode');

    // Resume and finish
    await harness.gate('resume', undefined, { decision: 'proceed' });

    for (let s = 2; s <= 5; s++) {
      if (s === 5) writeStage5OutputFile(harness);
      await harness.gate('start', s);
      const output = s === 2 ? STAGE_2_OUTPUT : s === 3 ? STAGE_3_OUTPUT : s === 4 ? STAGE_4_OUTPUT : STAGE_5_OUTPUT;
      await harness.gate('complete', s, output);
    }

    const finalState = harness.readRunState();
    assert.equal((finalState.completedStages as number[]).length, 6);
  });
});

// ============================================================
// Tests: Repair Unit with Renumbered Stages
// ============================================================

describe('E2E ISA Websearch Pipeline — Repair Unit Stages [3, 4]', () => {
  let harness: E2ESessionHarness;

  afterEach(() => {
    harness?.cleanup();
  });

  it('repair unit activates at stages 3/4, re-runs synthesize and verify', async () => {
    const config = loadRealISAConfig();
    harness = E2ESessionHarness.create({ agentConfig: config });

    // Run through stages 0-4 (with pauses at 0 and 1)
    await harness.gate('reset', undefined, { force: true });
    await harness.gate('start', 0);
    await harness.gate('complete', 0, STAGE_0_OUTPUT);
    await harness.gate('resume', undefined, { decision: 'proceed' });
    await harness.gate('start', 1);
    await harness.gate('complete', 1, STAGE_1_OUTPUT_EXECUTED);
    await harness.gate('resume', undefined, { decision: 'proceed' });
    await harness.gate('start', 2);
    await harness.gate('complete', 2, STAGE_2_OUTPUT);
    await harness.gate('start', 3);
    await harness.gate('complete', 3, STAGE_3_OUTPUT);
    await harness.gate('start', 4);

    // Verification fails
    const failedVerification = {
      verification_scores: {
        entity_grounding: { score: 0.92, passed: true },
        citation_accuracy: { score: 0.60, passed: false },
        relation_preservation: { score: 0.75, passed: true },
        contradictions: { count: 0, passed: true },
      },
      all_passed: false,
      source_texts: {},
      missing_source_texts: ['ip_001'],
      repair_instructions: {
        failed_axes: ['citation_accuracy'],
        specific_issues: ['Citation ip_001 not supported'],
      },
    };
    await harness.gate('complete', 4, failedVerification);

    // Start repair unit at stage 3 or 4 (handler finds matching repair unit)
    const repairStart = await harness.gate('start_repair_unit');
    assert.equal(repairStart.allowed, true, 'start_repair_unit should succeed at stage 4');
    assert.equal(repairStart.repairUnitActive, true);

    // Repair iteration 1
    const repair = await harness.gate('repair');
    assert.equal(repair.allowed, true, 'repair iteration 1 should be allowed');
    assert.equal(repair.repairIteration, 1);

    // Re-run stages 3 and 4
    const s3Restart = await harness.gate('start', 3);
    assert.equal(s3Restart.allowed, true, 'Re-starting stage 3 in repair should succeed');

    await harness.gate('complete', 3, { ...STAGE_3_OUTPUT, repair_feedback: 'Fixed citation' });

    await harness.gate('start', 4);
    await harness.gate('complete', 4, STAGE_4_OUTPUT); // Now passes

    // End repair unit
    const repairEnd = await harness.gate('end_repair_unit');
    assert.equal(repairEnd.allowed, true);
    assert.equal(repairEnd.repairUnitActive, false);

    // Continue to stage 5
    writeStage5OutputFile(harness);
    await harness.gate('start', 5);
    await harness.gate('complete', 5, STAGE_5_OUTPUT);

    const finalState = harness.readRunState();
    const completed = finalState.completedStages as number[];
    assert.equal(completed.length, 6, 'All 6 stages should be completed after repair');

    // Verify events include repair lifecycle
    const events = validateAgentEventsLog(harness.ctx, harness.agentSlug);
    assertEventSequence(events, [
      'repair_unit_started',
      'repair_iteration',
      'stage_started',          // re-start stage 3
      'stage_completed',        // re-complete stage 3
      'stage_started',          // re-start stage 4
      'stage_completed',        // re-complete stage 4
      'repair_unit_completed',
    ]);
  });

  it('repair unit NOT available at stage 1 (websearch_calibration)', async () => {
    const config = loadRealISAConfig();
    harness = E2ESessionHarness.create({ agentConfig: config });

    await harness.gate('reset', undefined, { force: true });
    await harness.gate('start', 0);
    await harness.gate('complete', 0, STAGE_0_OUTPUT);
    await harness.gate('resume', undefined, { decision: 'proceed' });
    await harness.gate('start', 1);
    await harness.gate('complete', 1, STAGE_1_OUTPUT_EXECUTED);
    await harness.gate('resume', undefined, { decision: 'proceed' });

    // Try to start repair unit while at stage 2 (after stage 1) — should fail
    // because repair unit is [3, 4], not [1, 2]
    await harness.gate('start', 2);
    const repairAttempt = await harness.gate('start_repair_unit');
    assert.equal(repairAttempt.allowed, false, 'Repair unit should not be available at stage 2');
    assert.ok(
      (repairAttempt.reason as string).includes('No repair unit defined'),
      'Reason should mention no repair unit defined for this stage',
    );
  });
});

// ============================================================
// Tests: Stage Output Schema Validation
// ============================================================

describe('E2E ISA Websearch Pipeline — Schema Validation', () => {
  let harness: E2ESessionHarness;

  afterEach(() => {
    harness?.cleanup();
  });

  it('stage 1 executed output passes schema validation', async () => {
    const config = loadRealISAConfig();
    harness = E2ESessionHarness.create({ agentConfig: config });

    await harness.gate('reset', undefined, { force: true });
    await harness.gate('start', 0);
    await harness.gate('complete', 0, STAGE_0_OUTPUT);
    await harness.gate('resume', undefined, { decision: 'proceed' });
    await harness.gate('start', 1);

    const result = await harness.gate('complete', 1, STAGE_1_OUTPUT_EXECUTED);
    assert.equal(
      result.validationWarnings,
      undefined,
      `Stage 1 executed output should pass schema validation. Warnings: ${JSON.stringify(result.validationWarnings)}`,
    );
  });

  it('stage 1 skipped output passes schema validation', async () => {
    const config = loadRealISAConfig();
    harness = E2ESessionHarness.create({ agentConfig: config });

    await harness.gate('reset', undefined, { force: true });
    await harness.gate('start', 0);
    await harness.gate('complete', 0, STAGE_0_OUTPUT);
    await harness.gate('resume', undefined, { decision: 'proceed' });
    await harness.gate('start', 1);

    const result = await harness.gate('complete', 1, STAGE_1_OUTPUT_SKIPPED_USER);
    assert.equal(
      result.validationWarnings,
      undefined,
      `Stage 1 skipped output should pass schema validation. Warnings: ${JSON.stringify(result.validationWarnings)}`,
    );
  });

  it('all 6 stage outputs pass their respective schemas without warnings', async () => {
    const config = loadRealISAConfig();
    harness = E2ESessionHarness.create({ agentConfig: config });

    const outputs: Record<number, Record<string, unknown>> = {
      0: STAGE_0_OUTPUT,
      1: STAGE_1_OUTPUT_EXECUTED,
      2: STAGE_2_OUTPUT,
      3: STAGE_3_OUTPUT,
      4: STAGE_4_OUTPUT,
      5: STAGE_5_OUTPUT,
    };

    await harness.gate('reset', undefined, { force: true });
    await harness.gate('start', 0);

    for (let s = 0; s <= 5; s++) {
      if (s === 5) writeStage5OutputFile(harness);
      const completeResult = await harness.gate('complete', s, outputs[s]);

      // Check for schema validation warnings
      if (completeResult.validationWarnings) {
        assert.fail(
          `Stage ${s} output failed schema validation: ${JSON.stringify(completeResult.validationWarnings)}`,
        );
      }

      // Resume if paused (stages 0 and 1)
      if (completeResult.pauseRequired) {
        await harness.gate('resume', undefined, { decision: 'proceed' });
      }

      // Start next stage
      if (s < 5) {
        await harness.gate('start', s + 1);
      }
    }
  });
});

// ============================================================
// Tests: Double-Pause Blocking
// ============================================================

describe('E2E ISA Websearch Pipeline — Double-Pause Enforcement', () => {
  let harness: E2ESessionHarness;

  afterEach(() => {
    harness?.cleanup();
  });

  it('paused at stage 0: blocks start(1), start(0), complete(0)', async () => {
    const config = loadRealISAConfig();
    harness = E2ESessionHarness.create({ agentConfig: config });

    await harness.gate('reset', undefined, { force: true });
    await harness.gate('start', 0);
    await harness.gate('complete', 0, STAGE_0_OUTPUT);

    // All operations blocked
    const s1 = await harness.gate('start', 1);
    assert.equal(s1.allowed, false, 'start(1) blocked while paused at 0');

    const s0Again = await harness.gate('start', 0);
    assert.equal(s0Again.allowed, false, 'start(0) blocked while paused at 0');

    const c0 = await harness.gate('complete', 0);
    assert.equal(c0.allowed, false, 'complete(0) blocked while paused at 0');
  });

  it('paused at stage 1: blocks start(2), complete(1), repair actions', async () => {
    const config = loadRealISAConfig();
    harness = E2ESessionHarness.create({ agentConfig: config });

    await harness.gate('reset', undefined, { force: true });
    await harness.gate('start', 0);
    await harness.gate('complete', 0, STAGE_0_OUTPUT);
    await harness.gate('resume', undefined, { decision: 'proceed' });
    await harness.gate('start', 1);
    await harness.gate('complete', 1, STAGE_1_OUTPUT_EXECUTED);

    // Verify paused at stage 1
    const state = harness.readRunState();
    assert.equal(state.pausedAtStage, 1);

    // All operations blocked
    const s2 = await harness.gate('start', 2);
    assert.equal(s2.allowed, false, 'start(2) blocked while paused at 1');

    const c1 = await harness.gate('complete', 1);
    assert.equal(c1.allowed, false, 'complete(1) blocked while paused at 1');

    const repair = await harness.gate('start_repair_unit');
    assert.equal(repair.allowed, false, 'start_repair_unit blocked while paused at 1');
  });

  it('resume after stage 1 pause unlocks stage 2', async () => {
    const config = loadRealISAConfig();
    harness = E2ESessionHarness.create({ agentConfig: config });

    await harness.gate('reset', undefined, { force: true });
    await harness.gate('start', 0);
    await harness.gate('complete', 0, STAGE_0_OUTPUT);
    await harness.gate('resume', undefined, { decision: 'proceed' });
    await harness.gate('start', 1);
    await harness.gate('complete', 1, STAGE_1_OUTPUT_EXECUTED);

    // Resume
    const resume = await harness.gate('resume', undefined, { decision: 'proceed' });
    assert.equal(resume.allowed, true);
    assert.equal(resume.nextStage, 2);

    // Now stage 2 is accessible
    const s2 = await harness.gate('start', 2);
    assert.equal(s2.allowed, true, 'start(2) should succeed after resume from stage 1');
  });

  it('abort at stage 1 pause terminates pipeline', async () => {
    const config = loadRealISAConfig();
    harness = E2ESessionHarness.create({ agentConfig: config });

    await harness.gate('reset', undefined, { force: true });
    await harness.gate('start', 0);
    await harness.gate('complete', 0, STAGE_0_OUTPUT);
    await harness.gate('resume', undefined, { decision: 'proceed' });
    await harness.gate('start', 1);
    await harness.gate('complete', 1, STAGE_1_OUTPUT_EXECUTED);

    // Abort at stage 1
    const abort = await harness.gate('resume', undefined, { decision: 'abort', reason: 'Changed mind' });
    assert.equal(abort.allowed, true);
    assert.equal(abort.aborted, true);

    // Pipeline state is cleared
    const status = await harness.gate('status');
    assert.equal(status.allowed, false, 'Status should show no active run after abort');
  });
});
