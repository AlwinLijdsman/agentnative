/**
 * E2E Task Boundary pauseLocked & Anti-Regeneration Guard Tests
 *
 * Validates the two bug fixes for ISA stage gate:
 *
 * Bug 1: managed.pauseLocked persists across Task call boundaries.
 *   - The pauseLocked flag is set during onAgentStagePause to prevent
 *     same-turn LLM self-resume. The fix clears it in sendMessage when
 *     resume context is injected (new user message = new Task boundary).
 *
 * Bug 2: Anti-regeneration guard forbids keywords needed by future stages.
 *   - The old guard said "no CALIBRATED, CONFIRMED, READY, CLARIFYING text"
 *     which blocked Stage 1 pauseInstructions. The fix makes the guard
 *     stage-specific: "Do NOT re-present the output from stage N."
 *
 * These tests use the stage-gate handler harness with ISA config (double-pause
 * at stages 0 and 1) and validate the resume context text generated by
 * getPausedAgentResumeContext().
 *
 * Run: npx tsx --test apps/electron/src/__tests__/e2e-task-boundary-pauselock.test.ts
 */

import { describe, it, afterEach } from 'node:test';
import assert from 'node:assert/strict';
import { join } from 'node:path';
import { readFileSync, existsSync } from 'node:fs';
import {
  E2ESessionHarness,
} from '../../../../packages/session-tools-core/src/handlers/__tests__/e2e-utils.ts';
import {
  validateAgentEventsLog,
  assertEventSequence,
  assertNoDuplicateCompletes,
} from '../../../../packages/session-tools-core/src/handlers/__tests__/e2e-session-validators.ts';

// ============================================================
// Load Real ISA Config
// ============================================================

const ISA_AGENT_CONFIG_PATH = join(
  process.cwd(),
  'agents',
  'isa-deep-research',
  'config.json',
);

function loadRealISAConfig(): Record<string, unknown> {
  assert.ok(
    existsSync(ISA_AGENT_CONFIG_PATH),
    `Real ISA config must exist at ${ISA_AGENT_CONFIG_PATH}`,
  );
  return JSON.parse(readFileSync(ISA_AGENT_CONFIG_PATH, 'utf-8')) as Record<string, unknown>;
}

// ============================================================
// Sample stage outputs
// ============================================================

const STAGE_0_OUTPUT = {
  query_plan: {
    original_query: 'What does ISA 315 require for risk assessment?',
    sub_queries: [
      { query: 'ISA 315 risk assessment requirements', role: 'primary', target_standards: ['315'] },
    ],
    depth_mode: 'standard',
    assumptions: ['Focus on revised ISA 315 (2019)'],
    recommended_action: 'proceed',
  },
};

const STAGE_1_OUTPUT_EXECUTED = {
  websearch_calibration: {
    skipped: false,
    web_queries_executed: 3,
    web_sources: [
      { url: 'https://ifac.org/isa-315', title: 'ISA 315 Guide', relevance_note: 'Primary' },
    ],
    intent_changes: {
      sub_queries_added: [],
      sub_queries_modified: [],
      sub_queries_removed: [],
      scope_changed: false,
      standards_added: [],
    },
    query_plan_refined: true,
  },
};

const STAGE_2_OUTPUT = {
  retrieval_summary: {
    total_paragraphs_found: 45,
    unique_after_dedup: 32,
    standards_covered: ['ISA 315', 'ISA 330'],
  },
};

const STAGE_3_OUTPUT = {
  synthesis: 'ISA 315 requires the auditor to identify and assess risks...',
  citations_used: [
    { paragraph_id: 'ip_001', paragraph_ref: '315.12(a)', claim: 'risk assessment requirement' },
  ],
};

const STAGE_4_OUTPUT = {
  verification_scores: {
    entity_grounding: { score: 0.92, passed: true },
    citation_accuracy: { score: 0.88, passed: true },
    relation_preservation: { score: 0.75, passed: true },
    contradictions: { count: 0, passed: true },
  },
  all_passed: true,
};

const STAGE_5_OUTPUT = {
  answer_delivered: true,
  total_citations: 12,
  output_file_path: './isa-research-output.md',
};

// ============================================================
// Bug 1: Task Boundary pauseLocked Simulation
// ============================================================

describe('E2E Task Boundary — pauseLocked Across Calls', () => {
  let harness: E2ESessionHarness;

  afterEach(() => {
    harness?.cleanup();
  });

  it('simulates Task architecture: pause at stage 0, new call resumes, pause at stage 1, new call resumes, completes pipeline', async () => {
    const config = loadRealISAConfig();
    harness = E2ESessionHarness.create({ agentConfig: config });

    // === Task Call 1: Stage 0 triggers pause ===
    await harness.gate('reset', undefined, { force: true });
    await harness.gate('start', 0);
    const s0Complete = await harness.gate('complete', 0, STAGE_0_OUTPUT);

    assert.equal(s0Complete.pauseRequired, true, 'Stage 0 should trigger pause');
    assert.equal(s0Complete.allowed, false, 'Operations should be blocked while paused');

    // Verify pause is enforced — simulates isPauseLocked returning true
    // In real code, managed.pauseLocked=true prevents LLM self-resume
    const blockedStart = await harness.gate('start', 1);
    assert.equal(blockedStart.allowed, false, 'start(1) must be blocked while paused at stage 0');

    // Verify run state persists pause
    const state0 = harness.readRunState();
    assert.equal(state0.pausedAtStage, 0, 'Run state should show pausedAtStage=0');

    // === Task Call 2: User sends "proceed" — new message boundary ===
    // In real code, sendMessage() detects resumeContext, clears pauseLocked, injects context.
    // Here we simulate the unlock by calling resume directly (since the harness doesn't
    // have a managed.pauseLocked — the stage-gate handler checks run state, not pauseLocked).
    const resume0 = await harness.gate('resume', undefined, { decision: 'proceed' });
    assert.equal(resume0.allowed, true, 'Resume should succeed (user-initiated, new call boundary)');
    assert.equal(resume0.nextStage, 1, 'Next stage should be 1');

    // Stage 1: start and complete — triggers second pause
    const s1Start = await harness.gate('start', 1);
    assert.equal(s1Start.allowed, true, 'start(1) should succeed after resume');

    const s1Complete = await harness.gate('complete', 1, STAGE_1_OUTPUT_EXECUTED);
    assert.equal(s1Complete.pauseRequired, true, 'Stage 1 should trigger second pause');

    // Verify second pause is enforced
    const blockedStart2 = await harness.gate('start', 2);
    assert.equal(blockedStart2.allowed, false, 'start(2) must be blocked while paused at stage 1');

    const state1 = harness.readRunState();
    assert.equal(state1.pausedAtStage, 1, 'Run state should show pausedAtStage=1');

    // === Task Call 3: User sends "proceed" — another new message boundary ===
    const resume1 = await harness.gate('resume', undefined, { decision: 'proceed' });
    assert.equal(resume1.allowed, true, 'Resume from stage 1 should succeed');
    assert.equal(resume1.nextStage, 2, 'Next stage should be 2');

    // === Stages 2-5: complete without pauses ===
    for (let s = 2; s <= 5; s++) {
      const startResult = await harness.gate('start', s);
      assert.equal(startResult.allowed, true, `start(${s}) should succeed`);
      const output = s === 2 ? STAGE_2_OUTPUT : s === 3 ? STAGE_3_OUTPUT : s === 4 ? STAGE_4_OUTPUT : STAGE_5_OUTPUT;
      const completeResult = await harness.gate('complete', s, output);
      assert.equal(completeResult.pauseRequired, false, `Stage ${s} should NOT pause`);
    }

    // Verify full pipeline completed
    const finalState = harness.readRunState();
    const completed = finalState.completedStages as number[];
    assert.equal(completed.length, 6, 'All 6 stages should be completed');

    // Verify event log integrity
    const events = validateAgentEventsLog(harness.ctx, harness.agentSlug);
    assertEventSequence(events, [
      'agent_run_started',     // start(0)
      'stage_completed',       // complete(0)
      'stage_gate_pause',      // pause at 0
      'stage_gate_resumed',    // resume (Task call 2)
      'stage_started',         // start(1)
      'stage_completed',       // complete(1)
      'stage_gate_pause',      // pause at 1
      'stage_gate_resumed',    // resume (Task call 3)
      'stage_started',         // start(2)
      'stage_completed',       // complete(2)
      'stage_started',         // start(3)
      'stage_completed',       // complete(3)
      'stage_started',         // start(4)
      'stage_completed',       // complete(4)
      'stage_started',         // start(5)
      'stage_completed',       // complete(5)
      'agent_run_completed',
    ]);

    assertNoDuplicateCompletes(events);
  });

  it('pause at each stage blocks all forward operations until explicit resume', async () => {
    const config = loadRealISAConfig();
    harness = E2ESessionHarness.create({ agentConfig: config });

    await harness.gate('reset', undefined, { force: true });
    await harness.gate('start', 0);
    await harness.gate('complete', 0, STAGE_0_OUTPUT);

    // While paused at stage 0: ALL operations are blocked
    const ops = [
      { action: 'start' as const, stage: 1, label: 'start(1)' },
      { action: 'start' as const, stage: 0, label: 'start(0) re-entry' },
      { action: 'complete' as const, stage: 0, label: 'complete(0) duplicate' },
      { action: 'start_repair_unit' as const, stage: undefined, label: 'start_repair_unit' },
    ];

    for (const op of ops) {
      const result = await harness.gate(op.action, op.stage);
      assert.equal(result.allowed, false, `${op.label} should be blocked while paused at stage 0`);
    }

    // Only resume unlocks
    const resume = await harness.gate('resume', undefined, { decision: 'proceed' });
    assert.equal(resume.allowed, true, 'Resume should succeed');

    // Now start(1) works
    const s1 = await harness.gate('start', 1);
    assert.equal(s1.allowed, true, 'start(1) should succeed after resume');
  });
});

// ============================================================
// Bug 2: Anti-Regeneration Guard — Stage-Specific Text
// ============================================================

describe('E2E Anti-Regeneration Guard — Stage-Specific Keywords', () => {
  it('getPausedAgentResumeContext text does NOT contain CALIBRATED/CONFIRMED/READY/CLARIFYING keywords', () => {
    // The anti-regeneration guard text is generated in sessions.ts
    // getPausedAgentResumeContext(). The fix changes the guard from:
    //   "no CALIBRATED, CONFIRMED, READY, CLARIFYING text"
    // to:
    //   "Do NOT re-present the output from stage {N}."
    //
    // We verify this by checking the template string pattern. Since we can't
    // call getPausedAgentResumeContext directly (it reads filesystem), we
    // verify the expected pattern using the sessions.ts source.

    const sessionsPath = join(
      process.cwd(),
      'apps',
      'electron',
      'src',
      'main',
      'sessions.ts',
    );
    assert.ok(existsSync(sessionsPath), 'sessions.ts should exist');
    const source = readFileSync(sessionsPath, 'utf-8');

    // Find the CRITICAL anti-regeneration guard line in getPausedAgentResumeContext
    const criticalLines = source.split('\n').filter(
      line => line.includes('CRITICAL') && line.includes('re-present'),
    );
    assert.ok(
      criticalLines.length >= 1,
      'Should find the CRITICAL anti-regeneration guard line in sessions.ts',
    );

    const guardLine = criticalLines[0]!;

    // The fix: guard should NOT contain these stage-1-specific keywords
    const forbiddenKeywords = ['CALIBRATED', 'CONFIRMED', 'READY', 'CLARIFYING'];
    for (const keyword of forbiddenKeywords) {
      assert.ok(
        !guardLine.includes(keyword),
        `Anti-regeneration guard should NOT contain "${keyword}" — ` +
        `this would block Stage 1 pauseInstructions. Guard line: ${guardLine.trim()}`,
      );
    }

    // The fix: guard should be stage-specific (references stage number dynamically)
    assert.ok(
      guardLine.includes('state.pausedAtStage') || guardLine.includes('${state.pausedAtStage}'),
      `Guard should reference pausedAtStage dynamically. Got: ${guardLine.trim()}`,
    );
  });

  it('Stage 1 pauseInstructions contain CALIBRATED and CONFIRMED keywords that were previously blocked', () => {
    const config = loadRealISAConfig() as {
      controlFlow: {
        stages: Array<{ id: number; pauseInstructions?: string }>;
      };
    };

    const stage1 = config.controlFlow.stages.find(s => s.id === 1);
    assert.ok(stage1, 'Stage 1 should exist in config');
    assert.ok(stage1.pauseInstructions, 'Stage 1 should have pauseInstructions');

    // These keywords are required by Stage 1's pauseInstructions format
    assert.ok(
      stage1.pauseInstructions!.includes('CALIBRATED'),
      'Stage 1 pauseInstructions must contain CALIBRATED',
    );
    assert.ok(
      stage1.pauseInstructions!.includes('CONFIRMED'),
      'Stage 1 pauseInstructions must contain CONFIRMED',
    );
  });

  it('Stage 1 pause reason includes CALIBRATED/CONFIRMED when pipeline reaches stage 1', async () => {
    const config = loadRealISAConfig();
    const harness = E2ESessionHarness.create({ agentConfig: config });

    try {
      await harness.gate('reset', undefined, { force: true });
      await harness.gate('start', 0);
      await harness.gate('complete', 0, STAGE_0_OUTPUT);
      await harness.gate('resume', undefined, { decision: 'proceed' });
      await harness.gate('start', 1);
      const result = await harness.gate('complete', 1, STAGE_1_OUTPUT_EXECUTED);

      assert.equal(result.pauseRequired, true, 'Stage 1 should pause');

      const reason = result.reason as string;
      assert.ok(
        reason.includes('CALIBRATED') && reason.includes('CONFIRMED'),
        `Stage 1 pause reason must contain CALIBRATED and CONFIRMED (from pauseInstructions). ` +
        `Got first 200 chars: ${reason.substring(0, 200)}`,
      );
    } finally {
      harness.cleanup();
    }
  });
});

// ============================================================
// Full Pipeline: Double-Pause with Interleaved Resume Calls
// ============================================================

describe('E2E Full Pipeline — Task Subagent Double-Pause Flow', () => {
  let harness: E2ESessionHarness;

  afterEach(() => {
    harness?.cleanup();
  });

  it('full 6-stage pipeline with two pause/resume cycles completes successfully', async () => {
    const config = loadRealISAConfig();
    harness = E2ESessionHarness.create({ agentConfig: config });

    // Task Call 1: Run stage 0 to pause
    await harness.gate('reset', undefined, { force: true });
    await harness.gate('start', 0);
    const s0 = await harness.gate('complete', 0, STAGE_0_OUTPUT);
    assert.equal(s0.pauseRequired, true);

    // Task Call 2: Resume stage 0, run stage 1 to pause
    await harness.gate('resume', undefined, { decision: 'proceed' });
    await harness.gate('start', 1);
    const s1 = await harness.gate('complete', 1, STAGE_1_OUTPUT_EXECUTED);
    assert.equal(s1.pauseRequired, true);

    // Task Call 3: Resume stage 1, run stages 2-5 to completion
    await harness.gate('resume', undefined, { decision: 'proceed' });

    const stageOutputs: Record<number, Record<string, unknown>> = {
      2: STAGE_2_OUTPUT,
      3: STAGE_3_OUTPUT,
      4: STAGE_4_OUTPUT,
      5: STAGE_5_OUTPUT,
    };

    for (let s = 2; s <= 5; s++) {
      await harness.gate('start', s);
      const result = await harness.gate('complete', s, stageOutputs[s]);
      assert.equal(result.pauseRequired, false, `Stage ${s} should not pause`);
    }

    // Verify final state
    const finalState = harness.readRunState();
    assert.equal((finalState.completedStages as number[]).length, 6);

    // Verify event log: two pause/resume cycles followed by straight-through execution
    const events = validateAgentEventsLog(harness.ctx, harness.agentSlug);

    // Count pause and resume events
    const pauses = events.filter(e => e.type === 'stage_gate_pause');
    const resumes = events.filter(e => e.type === 'stage_gate_resumed');
    assert.equal(pauses.length, 2, 'Should have exactly 2 pauses (stage 0 and 1)');
    assert.equal(resumes.length, 2, 'Should have exactly 2 resumes');

    // Verify pause stages
    assert.equal(pauses[0]!.data.stage, 0, 'First pause at stage 0');
    assert.equal(pauses[1]!.data.stage, 1, 'Second pause at stage 1');

    assertNoDuplicateCompletes(events);
  });

  it('abort at stage 1 after completing stage 0 terminates cleanly', async () => {
    const config = loadRealISAConfig();
    harness = E2ESessionHarness.create({ agentConfig: config });

    // Stage 0 -> pause -> resume
    await harness.gate('reset', undefined, { force: true });
    await harness.gate('start', 0);
    await harness.gate('complete', 0, STAGE_0_OUTPUT);
    await harness.gate('resume', undefined, { decision: 'proceed' });

    // Stage 1 -> pause -> abort
    await harness.gate('start', 1);
    await harness.gate('complete', 1, STAGE_1_OUTPUT_EXECUTED);

    const abort = await harness.gate('resume', undefined, {
      decision: 'abort',
      reason: 'User changed mind after seeing websearch results',
    });
    assert.equal(abort.allowed, true, 'Abort should succeed');
    assert.equal(abort.aborted, true, 'Aborted flag should be true');

    // Pipeline is terminated — status shows no active run
    const status = await harness.gate('status');
    assert.equal(status.allowed, false, 'No active run after abort');
  });

  it('modify at stage 0 passes modifications through stage 1 boundary', async () => {
    const config = loadRealISAConfig();
    harness = E2ESessionHarness.create({ agentConfig: config });

    await harness.gate('reset', undefined, { force: true });
    await harness.gate('start', 0);
    await harness.gate('complete', 0, STAGE_0_OUTPUT);

    // Resume with modify (user wants to skip websearch)
    const resume = await harness.gate('resume', undefined, {
      decision: 'modify',
      modifications: { skip_websearch: true, user_note: 'Skip web search, proceed directly' },
    });
    assert.equal(resume.allowed, true);

    // Start stage 1 — modifications delivered
    const s1Start = await harness.gate('start', 1);
    assert.equal(s1Start.allowed, true);
    assert.deepEqual(
      s1Start.modifications,
      { skip_websearch: true, user_note: 'Skip web search, proceed directly' },
      'Modifications from stage 0 resume should pass to stage 1 start',
    );

    // Complete stage 1 (skipped websearch)
    const s1Complete = await harness.gate('complete', 1, {
      websearch_calibration: {
        skipped: true,
        skip_reason: 'user_declined',
        web_queries_executed: 0,
        web_sources: [],
        intent_changes: {
          sub_queries_added: [],
          sub_queries_modified: [],
          sub_queries_removed: [],
          scope_changed: false,
          standards_added: [],
        },
        query_plan_refined: false,
      },
    });
    assert.equal(s1Complete.pauseRequired, true, 'Stage 1 still pauses even when skipped');

    // Resume stage 1 and start stage 2 — modifications should be consumed
    await harness.gate('resume', undefined, { decision: 'proceed' });
    const s2Start = await harness.gate('start', 2);
    assert.equal(
      s2Start.modifications,
      undefined,
      'Modifications should be consumed — not re-delivered to stage 2',
    );
  });
});
