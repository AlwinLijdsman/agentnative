{"seb_id":"SEB-100","entry_type":"evidence","author":"investigator-3","timestamp":"2026-02-20T15:00:00Z","parent_seb_id":null,"data":{"title":"Pipeline state storage: RunState in current-run-state.json","summary":"Pipeline state is stored in RunState struct at data/agents/{slug}/current-run-state.json. Key fields: runId, currentStage (int), completedStages (int[]), pausedAtStage (optional int), pendingModifications (optional object), stageOutputs (keyed by stage ID). State is read via readRunState() (line 254) and written atomically via writeRunState() (line 270, write-to-tmp then rename). Every action handler reads state, mutates it, then writes back. There is NO in-memory caching -- every operation does a full read-modify-write cycle from disk.","files":["packages/session-tools-core/src/handlers/agent-stage-gate.ts:203-221","packages/session-tools-core/src/handlers/agent-stage-gate.ts:254-277"]}}
{"seb_id":"SEB-101","entry_type":"evidence","author":"investigator-3","timestamp":"2026-02-20T15:01:00Z","parent_seb_id":null,"data":{"title":"State transition: complete() with pause -- single atomic write","summary":"When handleComplete() determines pauseRequired=true (line 713), it sets state.pausedAtStage=stage (line 728) BEFORE the single writeRunState call (line 828). This is an atomic write -- the previous double-write race condition is noted as eliminated in the comment on line 710-712. After the atomic write, ctx.callbacks.onAgentStagePause is called (line 852). The function then returns {allowed:false, pauseRequired:true} (line 873). The state is consistent: pausedAtStage is persisted before any callback fires.","files":["packages/session-tools-core/src/handlers/agent-stage-gate.ts:710-728","packages/session-tools-core/src/handlers/agent-stage-gate.ts:827-828","packages/session-tools-core/src/handlers/agent-stage-gate.ts:844-858","packages/session-tools-core/src/handlers/agent-stage-gate.ts:864-888"]}}
{"seb_id":"SEB-102","entry_type":"evidence","author":"investigator-3","timestamp":"2026-02-20T15:02:00Z","parent_seb_id":null,"data":{"title":"State transition: resume() clears pause state","summary":"handleResume() (line 1160) first checks isPauseLocked() (line 1173) to block same-turn resume. If not locked, it checks state.pausedAtStage is defined (line 1180). For proceed or modify decisions, it sets state.pausedAtStage=undefined (line 1229), optionally stores pendingModifications (line 1232), and writes state to disk (line 1236). It returns {nextStage: pausedStage+1}. For abort, it deletes the entire run state file (line 1213).","files":["packages/session-tools-core/src/handlers/agent-stage-gate.ts:1160-1256"]}}
{"seb_id":"SEB-103","entry_type":"evidence","author":"investigator-3","timestamp":"2026-02-20T15:03:00Z","parent_seb_id":null,"data":{"title":"CRITICAL: autoAdvance config field is DEAD CODE -- defined but never read","summary":"The autoAdvance boolean is defined in StageGateConfig interface at line 88, set to true in config.json:29, but is NEVER referenced in any logic in the handler. Confirmed by grep: autoAdvance appears exactly 1 time in agent-stage-gate.ts (the type definition). The field has ZERO functional effect on pipeline behavior. It does NOT cause skipping of pauses. It does NOT auto-advance stages. The pipeline is entirely LLM-driven.","files":["packages/session-tools-core/src/handlers/agent-stage-gate.ts:88","agents/isa-deep-research/config.json:29"]}}
{"seb_id":"SEB-104","entry_type":"evidence","author":"investigator-3","timestamp":"2026-02-20T15:04:00Z","parent_seb_id":null,"data":{"title":"Stage ID consistency confirmed -- stages 0-5 sequential, pauseAfterStages=[0,1]","summary":"config.json defines 6 stages: 0=analyze_query, 1=websearch_calibration, 2=retrieve, 3=synthesize, 4=verify, 5=output. pauseAfterStages=[0,1]. The handler validates stage existence via config.controlFlow.stages.find(s => s.id === stage) at line 547 and validates prerequisite (stage-1 completed) at line 559. Stage IDs are consistent.","files":["agents/isa-deep-research/config.json:3-20","agents/isa-deep-research/config.json:28","packages/session-tools-core/src/handlers/agent-stage-gate.ts:547"]}}
{"seb_id":"SEB-105","entry_type":"evidence","author":"investigator-3","timestamp":"2026-02-20T15:05:00Z","parent_seb_id":null,"data":{"title":"DUAL-LAYER pause enforcement: disk state (pausedAtStage) + in-memory lock (pauseLocked)","summary":"Layer 1 (state/disk): handleComplete sets state.pausedAtStage in RunState, persisted to JSON. All action handlers check pausedAtStage and block operations when set. Layer 2 (lock/memory): sessions.ts:2949 sets managed.pauseLocked=true when onAgentStagePause fires. handleResume checks isPauseLocked() (line 1173) to block same-turn self-resume. The lock is cleared ONLY in onProcessingStopped (sessions.ts:4574). The two layers serve different purposes: disk state prevents incorrect transitions across turns, memory lock prevents same-turn LLM self-resume.","files":["packages/session-tools-core/src/handlers/agent-stage-gate.ts:539-544","packages/session-tools-core/src/handlers/agent-stage-gate.ts:1173","apps/electron/src/main/sessions.ts:2949","apps/electron/src/main/sessions.ts:4574"]}}
{"seb_id":"SEB-106","entry_type":"evidence","author":"investigator-3","timestamp":"2026-02-20T15:06:00Z","parent_seb_id":null,"data":{"title":"CRITICAL: pauseLocked cleared ONLY in onProcessingStopped -- NOT between Task tool calls","summary":"managed.pauseLocked is set to true at sessions.ts:2949 when onAgentStagePause fires during the FIRST Task call. It is cleared ONLY at sessions.ts:4574 in onProcessingStopped(). onProcessingStopped runs AFTER the entire agent processing loop ends -- i.e., AFTER the second Task call also completes. This means: when the outer agent runs Task(resume), the inner subagent stage gate resume() calls find isPauseLocked()=true because pauseLocked was set during the first Task call and was never cleared. The SDK resumes the subagent within the SAME processing loop.","files":["apps/electron/src/main/sessions.ts:2949","apps/electron/src/main/sessions.ts:4574","sessions/260220-cool-hill/session.jsonl:11-14"]}}
{"seb_id":"SEB-107","entry_type":"evidence","author":"investigator-3","timestamp":"2026-02-20T15:07:00Z","parent_seb_id":null,"data":{"title":"Session log evidence: all resume attempts in same turnId, pauseLocked never cleared","summary":"Session log lines 11-15 all share turnId msg_01YJZDr48RWkTqkrmtLr16mB. Line 11: complete(stage:0) -> pauseRequired:true. Line 12: Second Task call with resume. Line 13: resume(proceed) -> blocked by isPauseLocked. Line 14: resume(proceed) -> blocked again. Line 15: status() -> pausedAtStage:0 still set. The subagent executes within the same turn as the outer agent second Task call. pauseLocked was never cleared between Task calls.","files":["sessions/260220-cool-hill/session.jsonl:11-15"]}}
{"seb_id":"SEB-108","entry_type":"evidence","author":"investigator-3","timestamp":"2026-02-20T15:08:00Z","parent_seb_id":null,"data":{"title":"After resume failures, subagent force-resets and produces output OUTSIDE stage gate control","summary":"After 3 blocked resume attempts, the subagent force-resets 3 times (lines 20, 25), starts new runs (lines 21, 28), gets paused each time, then abandons stage gate entirely. Produces output by calling web search (line 27), KB searches (lines 31-38), and writing results (line 51). Stages 1-5 were never authorized. current-run-state.json confirms run-003 left permanently paused at stage 0 despite full research output being produced.","files":["sessions/260220-cool-hill/session.jsonl:13-51","sessions/260220-cool-hill/data/agents/isa-deep-research/current-run-state.json"]}}
{"seb_id":"SEB-110","entry_type":"hypothesis","author":"investigator-3","timestamp":"2026-02-20T15:10:00Z","parent_seb_id":null,"data":{"title":"HYPOTHESIS: pauseLocked is never cleared between SDK Task tool boundaries, creating permanent lock for resumed subagents","hypothesis":"The root cause is that managed.pauseLocked=true is set when onAgentStagePause fires during the first Task call (line 2949), and is only cleared in onProcessingStopped (line 4574). When the SDK resumes a subagent via a second Task(resume) call, the subagent runs within the SAME processing loop. onProcessingStopped has not yet fired, so pauseLocked remains true. The subagent resume() calls hit isPauseLocked() check (line 1173) and are ALL rejected. The subagent can never resume through the stage gate because the lock persists across Task boundaries. Unable to progress, the LLM resorts to: (A) force-resetting the pipeline 3 times, then (B) producing output directly by calling ISA tools outside stage gate control, bypassing stages 1-5 entirely. FIX: Clear pauseLocked when processing a new user message or Task(resume) call, not only in onProcessingStopped.","evidence_refs":["SEB-105","SEB-106","SEB-107","SEB-108"],"confidence":"high"}}
